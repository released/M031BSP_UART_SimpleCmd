; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Function_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  Function_Process PROC
;;;167    
;;;168    void Function_Process(Function_Index idx)
000000  b51c              PUSH     {r2-r4,lr}
;;;169    {
;;;170    	uint16_t res = 0;
;;;171    	switch(idx)
;;;172    	{
;;;173    		case Function_AAA:
;;;174    		/*
;;;175    			Function_AAA command template example :	
;;;176    			\30			\F5		\4		\30		\32		\39		\35		\0x00 - (byte 0 + .. byte 6)	\36
;;;177    
;;;178    			==> \30\F5\04\30\32\39\35\*07*\36	, res = 295
;;;179    			==> \30\F5\04\31\34\34\33\*0B*\36	, res = 1443
;;;180    		*/
;;;181    		
;;;182    		res = (cmd->data[0] -'0')*1000 +
000002  4919              LDR      r1,|L1.104|
000004  28d3              CMP      r0,#0xd3              ;171
000006  68ca              LDR      r2,[r1,#0xc]          ;171
000008  d022              BEQ      |L1.80|
00000a  dc06              BGT      |L1.26|
00000c  28a0              CMP      r0,#0xa0              ;171
00000e  d01f              BEQ      |L1.80|
000010  28b1              CMP      r0,#0xb1              ;171
000012  d01d              BEQ      |L1.80|
000014  28c2              CMP      r0,#0xc2              ;171
000016  d11a              BNE      |L1.78|
000018  e01a              B        |L1.80|
                  |L1.26|
00001a  28e4              CMP      r0,#0xe4              ;171
00001c  d018              BEQ      |L1.80|
00001e  28f5              CMP      r0,#0xf5              ;171
000020  d115              BNE      |L1.78|
000022  78d1              LDRB     r1,[r2,#3]
000024  247d              MOVS     r4,#0x7d
000026  00e4              LSLS     r4,r4,#3
000028  3930              SUBS     r1,r1,#0x30
00002a  7993              LDRB     r3,[r2,#6]
00002c  4361              MULS     r1,r4,r1
00002e  185b              ADDS     r3,r3,r1
000030  7911              LDRB     r1,[r2,#4]
000032  2464              MOVS     r4,#0x64
000034  4361              MULS     r1,r4,r1
000036  7952              LDRB     r2,[r2,#5]
000038  240a              MOVS     r4,#0xa
00003a  4362              MULS     r2,r4,r2
00003c  1889              ADDS     r1,r1,r2
00003e  4a0b              LDR      r2,|L1.108|
000040  1859              ADDS     r1,r3,r1
000042  1889              ADDS     r1,r1,r2
000044  b28a              UXTH     r2,r1
;;;183    			(cmd->data[1] -'0')*100 + 
;;;184    			(cmd->data[2] -'0')*10 + 
;;;185    			(cmd->data[3] -'0')*1;
;;;186    
;;;187    		printf("\r\nFunction : 0x%2X , res = %2d\r\n", idx , res);
000046  4601              MOV      r1,r0
000048  a009              ADR      r0,|L1.112|
00004a  f7fffffe          BL       __2printf
                  |L1.78|
;;;188    		
;;;189    		break;
;;;190    
;;;191    		case Function_BBB:
;;;192    		/*
;;;193    			Function_BBB command template example :	
;;;194    			\30			\E4		\4		\0A		\0B		\0C		\0D		\0x00 - (byte 0 + .. byte 6)	\36
;;;195    
;;;196    			==> \30\E4\04\0A\0B\0C\0D\*BA*\36
;;;197    			==> \30\E4\04\10\20\30\40\*48*\36
;;;198    		*/
;;;199    		printf("\r\nFunction : 0x%2X , 0x%2X , 0x%2X , 0x%2X , 0x%2X , \r\n", idx , 
;;;200    				cmd->data[0],
;;;201    				cmd->data[1],
;;;202    				cmd->data[2],
;;;203    				cmd->data[3]);
;;;204    		
;;;205    		break;
;;;206    
;;;207    		case Function_CCC:
;;;208    		printf("\r\nFunction : 0x%2X , 0x%2X , 0x%2X , 0x%2X , 0x%2X , \r\n", idx , 
;;;209    				cmd->data[0],
;;;210    				cmd->data[1],
;;;211    				cmd->data[2],
;;;212    				cmd->data[3]);
;;;213    		break;
;;;214    
;;;215    		case Function_DDD:
;;;216    		printf("\r\nFunction : 0x%2X , 0x%2X , 0x%2X , 0x%2X , 0x%2X , \r\n", idx , 
;;;217    				cmd->data[0],
;;;218    				cmd->data[1],
;;;219    				cmd->data[2],
;;;220    				cmd->data[3]);
;;;221    		break;
;;;222    
;;;223    		case Function_EEE:
;;;224    		printf("\r\nFunction : 0x%2X , 0x%2X , 0x%2X , 0x%2X , 0x%2X , \r\n", idx , 
;;;225    				cmd->data[0],
;;;226    				cmd->data[1],
;;;227    				cmd->data[2],
;;;228    				cmd->data[3]);
;;;229    		break;
;;;230    
;;;231    		case Function_FFF:
;;;232    		printf("\r\nFunction : 0x%2X , 0x%2X , 0x%2X , 0x%2X , 0x%2X , \r\n", idx , 
;;;233    				cmd->data[0],
;;;234    				cmd->data[1],
;;;235    				cmd->data[2],
;;;236    				cmd->data[3]);
;;;237    		break;
;;;238    		
;;;239    	}
;;;240    }
00004e  bd1c              POP      {r2-r4,pc}
                  |L1.80|
000050  7993              LDRB     r3,[r2,#6]            ;232
000052  7951              LDRB     r1,[r2,#5]            ;232
000054  9100              STR      r1,[sp,#0]            ;232
000056  9301              STR      r3,[sp,#4]            ;232
000058  7913              LDRB     r3,[r2,#4]            ;232
00005a  4601              MOV      r1,r0                 ;232
00005c  78d2              LDRB     r2,[r2,#3]            ;232
00005e  a00d              ADR      r0,|L1.148|
000060  f7fffffe          BL       __2printf
000064  bd1c              POP      {r2-r4,pc}
;;;241    
                          ENDP

000066  0000              DCW      0x0000
                  |L1.104|
                          DCD      ||.data||
                  |L1.108|
                          DCD      0xffffeb30
                  |L1.112|
000070  0d0a4675          DCB      "\r\nFunction : 0x%2X , res = %2d\r\n",0
000074  6e637469
000078  6f6e203a
00007c  20307825
000080  3258202c
000084  20726573
000088  203d2025
00008c  32640d0a
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L1.148|
000094  0d0a4675          DCB      "\r\nFunction : 0x%2X , 0x%2X , 0x%2X , 0x%2X , 0x%2X , "
000098  6e637469
00009c  6f6e203a
0000a0  20307825
0000a4  3258202c
0000a8  20307825
0000ac  3258202c
0000b0  20307825
0000b4  3258202c
0000b8  20307825
0000bc  3258202c
0000c0  20307825
0000c4  3258202c
0000c8  20      
0000c9  0d0a00            DCB      "\r\n",0

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;278    
;;;279    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L2.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;282    }
00000c  bd10              POP      {r4,pc}
;;;283    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40004040

                          AREA ||i.GetChecksum||, CODE, READONLY, ALIGN=1

                  GetChecksum PROC
;;;123    */
;;;124    uint8_t GetChecksum(Cmd_Struct *cmd)
000000  2100              MOVS     r1,#0
;;;125    {
;;;126        uint16_t i = 0;
;;;127        uint8_t u8Checksum = 0;
000002  460a              MOV      r2,r1
                  |L3.4|
;;;128        uint8_t* u8Ptr = (uint8_t*)cmd;
;;;129    	
;;;130        for (i = 0 ; i < UARTCMD_CHKSUM_OFFSET - 1; i++)
;;;131        {
;;;132            u8Checksum += *(u8Ptr+i);
000004  5c43              LDRB     r3,[r0,r1]
000006  1c49              ADDS     r1,r1,#1
000008  189a              ADDS     r2,r3,r2
00000a  b289              UXTH     r1,r1                 ;130
00000c  b2d2              UXTB     r2,r2
00000e  2907              CMP      r1,#7                 ;130
000010  d3f8              BCC      |L3.4|
;;;133        }
;;;134    	
;;;135        return (uint8_t) (0 - u8Checksum);
000012  4250              RSBS     r0,r2,#0
000014  b2c0              UXTB     r0,r0
;;;136    }
000016  4770              BX       lr
;;;137    
                          ENDP


                          AREA ||i.ParseCmd_Process||, CODE, READONLY, ALIGN=2

                  ParseCmd_Process PROC
;;;241    
;;;242    void ParseCmd_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244    	uint16_t len = g_u16UART_RX_length;
000002  4d0f              LDR      r5,|L4.64|
;;;245        uint8_t checksumCal = 0;
;;;246    	
;;;247    	//copy buffer into cmd structure
;;;248    	cmd = (Cmd_Struct*)	g_au8UART_RX_Buffer;
000004  4a0f              LDR      r2,|L4.68|
000006  88ac              LDRH     r4,[r5,#4]            ;244  ; g_u16UART_RX_length
;;;249    
;;;250    	//check packet header and tail if correct format
;;;251    	if ((g_au8UART_RX_Buffer[cmd_idx_header] == CMD_HEADER) && 
000008  60ea              STR      r2,[r5,#0xc]  ; cmd
00000a  7813              LDRB     r3,[r2,#0]  ; g_au8UART_RX_Buffer
00000c  2000              MOVS     r0,#0                 ;245
00000e  2b30              CMP      r3,#0x30
000010  d105              BNE      |L4.30|
;;;252    		(g_au8UART_RX_Buffer[cmd_idx_tail] == CMD_TAIL))
000012  7a11              LDRB     r1,[r2,#8]  ; g_au8UART_RX_Buffer
000014  2936              CMP      r1,#0x36
000016  d102              BNE      |L4.30|
000018  4610              MOV      r0,r2
;;;253    	{
;;;254    		checksumCal = GetChecksum(cmd);
00001a  f7fffffe          BL       GetChecksum
                  |L4.30|
;;;255    	}
;;;256    		
;;;257    	//compare checksum correct or bypass this packet
;;;258    	if (checksumCal == cmd->checksum)	
00001e  68ea              LDR      r2,[r5,#0xc]  ; cmd
000020  79d1              LDRB     r1,[r2,#7]
000022  4281              CMP      r1,r0
000024  d103              BNE      |L4.46|
;;;259    	{
;;;260    		Function_Process(cmd->function);
000026  7850              LDRB     r0,[r2,#1]
000028  f7fffffe          BL       Function_Process
;;;261    	}
;;;262    	else
;;;263    	{
;;;264    		/*
;;;265    			if parse with incorrect format ,
;;;266    			ex : 
;;;267    
;;;268    			==> \12\34\550A\0B\0C\0D\BD
;;;269    			==> \34\0B\01\00\00\00\00\F4\81
;;;270    			==> \34\28\04\11\22\33\44\2A\81
;;;271    		*/
;;;272    		printf("\r\nIncorrect cmd format or checksum !!! \r\n");
;;;273    		dump_buff_hex((uint8_t *)g_au8UART_RX_Buffer,len);
;;;274    	}
;;;275    
;;;276    		
;;;277    }
00002c  bd70              POP      {r4-r6,pc}
                  |L4.46|
00002e  a006              ADR      r0,|L4.72|
000030  f7fffffe          BL       __2printf
000034  4621              MOV      r1,r4                 ;273
000036  4803              LDR      r0,|L4.68|
000038  f7fffffe          BL       dump_buff_hex
00003c  bd70              POP      {r4-r6,pc}
;;;278    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      ||.data||
                  |L4.68|
                          DCD      ||.bss||
                  |L4.72|
000048  0d0a496e          DCB      "\r\nIncorrect cmd format or checksum !!! \r\n",0
00004c  636f7272
000050  65637420
000054  636d6420
000058  666f726d
00005c  6174206f
000060  72206368
000064  65636b73
000068  756d2021
00006c  2121200d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;407    
;;;408    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1a              LDR      r4,|L5.112|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L5.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L5.10|
;;;409    {
;;;410        /* Unlock protected registers */
;;;411        SYS_UnlockReg();
;;;412    
;;;413        /* Enable HIRC clock (Internal RC 48MHz) */
;;;414        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;415    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;416    	
;;;417        /* Wait for HIRC clock ready */
;;;418        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;419    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;420    	
;;;421        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;422        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;423    
;;;424        /* Enable UART0 clock */
;;;425        CLK_EnableModuleClock(UART0_MODULE);
00002a  4d12              LDR      r5,|L5.116|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_EnableModuleClock
;;;426        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000032  2101              MOVS     r1,#1
000034  2200              MOVS     r2,#0
000036  0689              LSLS     r1,r1,#26
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_SetModuleClock
;;;427    	
;;;428        CLK_EnableModuleClock(TMR3_MODULE);
00003e  4d0e              LDR      r5,|L5.120|
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       CLK_EnableModuleClock
;;;429        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000046  2101              MOVS     r1,#1
000048  2200              MOVS     r2,#0
00004a  0549              LSLS     r1,r1,#21
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       CLK_SetModuleClock
;;;430    	
;;;431    
;;;432        /* Update System Core Clock */
;;;433        SystemCoreClockUpdate();
000052  f7fffffe          BL       SystemCoreClockUpdate
;;;434    
;;;435        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;436        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000056  07a8              LSLS     r0,r5,#30
000058  6bc1              LDR      r1,[r0,#0x3c]
00005a  22ff              MOVS     r2,#0xff
00005c  0412              LSLS     r2,r2,#16
00005e  4391              BICS     r1,r1,r2
000060  2233              MOVS     r2,#0x33
000062  0452              LSLS     r2,r2,#17
000064  1889              ADDS     r1,r1,r2
000066  63c1              STR      r1,[r0,#0x3c]
000068  2000              MOVS     r0,#0
00006a  6020              STR      r0,[r4,#0]
;;;437                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;438    
;;;439        /* Lock protected registers */
;;;440        SYS_LockReg();
;;;441    }
00006c  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP

00006e  0000              DCW      0x0000
                  |L5.112|
                          DCD      0x40000100
                  |L5.116|
                          DCD      0x5f803d10
                  |L5.120|
                          DCD      0x5f400005

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;301    
;;;302    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;303    {
;;;304        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L6.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L6.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;305        TIMER_EnableInt(TIMER3);
;;;306        NVIC_EnableIRQ(TMR3_IRQn);	
;;;307        TIMER_Start(TIMER3);
;;;308    }
000028  bd10              POP      {r4,pc}
;;;309    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40051020
                  |L6.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;283    
;;;284    void TMR3_IRQHandler(void)
000000  480a              LDR      r0,|L7.44|
000002  6881              LDR      r1,[r0,#8]
000004  07c9              LSLS     r1,r1,#31
000006  0fc9              LSRS     r1,r1,#31
;;;285    {
000008  d00f              BEQ      |L7.42|
00000a  2301              MOVS     r3,#1
00000c  6083              STR      r3,[r0,#8]
;;;286    //	static uint32_t LOG = 0;
;;;287    	static uint16_t CNT = 0;
;;;288    	
;;;289        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;290        {
;;;291            TIMER_ClearIntFlag(TIMER3);
;;;292    
;;;293    		if (CNT++ >= 1000)
00000e  4908              LDR      r1,|L7.48|
000010  88c8              LDRH     r0,[r1,#6]  ; CNT
000012  1c42              ADDS     r2,r0,#1
000014  80ca              STRH     r2,[r1,#6]
000016  227d              MOVS     r2,#0x7d
000018  00d2              LSLS     r2,r2,#3
00001a  4290              CMP      r0,r2
00001c  d305              BCC      |L7.42|
;;;294    		{		
;;;295    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  80c8              STRH     r0,[r1,#6]
;;;296    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;297    			PB14 ^= 1;
000022  4804              LDR      r0,|L7.52|
000024  6b81              LDR      r1,[r0,#0x38]
000026  4059              EORS     r1,r1,r3
000028  6381              STR      r1,[r0,#0x38]
                  |L7.42|
;;;298    		}		
;;;299        }
;;;300    }
00002a  4770              BX       lr
;;;301    
                          ENDP

                  |L7.44|
                          DCD      0x40051020
                  |L7.48|
                          DCD      ||.data||
                  |L7.52|
                          DCD      0x40004840

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;333    
;;;334    void UART02_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;335    {
;;;336        uint8_t i;
;;;337        static uint16_t u16UART_RX_Buffer_Index = 0;
;;;338    
;;;339    	if ((UART_GET_INT_FLAG(UART0,UART_INTSTS_RDAINT_Msk)))
000002  4d19              LDR      r5,|L8.104|
000004  69e8              LDR      r0,[r5,#0x1c]
000006  2600              MOVS     r6,#0
000008  05c0              LSLS     r0,r0,#23
;;;340    	{
;;;341            /* UART receive data available flag */
;;;342            
;;;343            /* Record RDA interrupt trigger times */
;;;344            g_u8UART_RDA_Trigger_Cnt++;
00000a  4c18              LDR      r4,|L8.108|
;;;345            
;;;346            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;347            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;348            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;349            {
;;;350                g_au8UART_RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
00000c  4a18              LDR      r2,|L8.112|
00000e  2800              CMP      r0,#0                 ;339
000010  da11              BGE      |L8.54|
000012  7860              LDRB     r0,[r4,#1]            ;344  ; g_u8UART_RDA_Trigger_Cnt
000014  1c40              ADDS     r0,r0,#1              ;344
000016  7060              STRB     r0,[r4,#1]            ;344
000018  2000              MOVS     r0,#0                 ;348
                  |L8.26|
00001a  682b              LDR      r3,[r5,#0]
00001c  8921              LDRH     r1,[r4,#8]  ; u16UART_RX_Buffer_Index
00001e  5453              STRB     r3,[r2,r1]
000020  1c49              ADDS     r1,r1,#1
;;;351                u16UART_RX_Buffer_Index ++;
000022  b289              UXTH     r1,r1
000024  8121              STRH     r1,[r4,#8]
;;;352    
;;;353                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
000026  2980              CMP      r1,#0x80
000028  d300              BCC      |L8.44|
;;;354                    u16UART_RX_Buffer_Index = 0;
00002a  8126              STRH     r6,[r4,#8]
                  |L8.44|
00002c  1c40              ADDS     r0,r0,#1
00002e  b2c0              UXTB     r0,r0                 ;348
000030  2803              CMP      r0,#3                 ;348
000032  d3f2              BCC      |L8.26|
                  |L8.52|
;;;355            }	
;;;356    	}
;;;357        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
;;;358        {
;;;359            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;360    
;;;361            /* Record Timeout times */
;;;362            g_u8UART_RXTO_Trigger_Cnt++;
;;;363    
;;;364            /* Move the last data from Rx FIFO to sw buffer. */
;;;365            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;366            {
;;;367                g_au8UART_RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
;;;368                u16UART_RX_Buffer_Index ++;
;;;369            }
;;;370    
;;;371            /* Clear UART RX parameter */
;;;372            UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;373    		g_u16UART_RX_length = u16UART_RX_Buffer_Index;
;;;374            u16UART_RX_Buffer_Index = 0;
;;;375            g_bUART_RX_Received_Data_State = eUART_RX_Received_Data_Finish;
;;;376        }
;;;377    	
;;;378    }
000034  bd70              POP      {r4-r6,pc}
                  |L8.54|
000036  69e8              LDR      r0,[r5,#0x1c]         ;357
000038  04c0              LSLS     r0,r0,#19             ;357
00003a  d5fb              BPL      |L8.52|
00003c  78a0              LDRB     r0,[r4,#2]            ;362  ; g_u8UART_RXTO_Trigger_Cnt
00003e  1c40              ADDS     r0,r0,#1              ;362
000040  70a0              STRB     r0,[r4,#2]            ;362
000042  e004              B        |L8.78|
                  |L8.68|
000044  6829              LDR      r1,[r5,#0]            ;367
000046  8920              LDRH     r0,[r4,#8]            ;367  ; u16UART_RX_Buffer_Index
000048  5411              STRB     r1,[r2,r0]            ;367
00004a  1c40              ADDS     r0,r0,#1              ;367
00004c  8120              STRH     r0,[r4,#8]            ;368
                  |L8.78|
00004e  69a8              LDR      r0,[r5,#0x18]         ;365
000050  0440              LSLS     r0,r0,#17             ;365
000052  d5f7              BPL      |L8.68|
000054  6868              LDR      r0,[r5,#4]            ;372
000056  2111              MOVS     r1,#0x11              ;372
000058  4388              BICS     r0,r0,r1              ;372
00005a  6068              STR      r0,[r5,#4]            ;372
00005c  8920              LDRH     r0,[r4,#8]            ;373  ; u16UART_RX_Buffer_Index
00005e  80a0              STRH     r0,[r4,#4]            ;373
000060  8126              STRH     r6,[r4,#8]            ;374
000062  7026              STRB     r6,[r4,#0]            ;375
000064  bd70              POP      {r4-r6,pc}
;;;379    
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      0x40070000
                  |L8.108|
                          DCD      ||.data||
                  |L8.112|
                          DCD      ||.bss||

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;379    
;;;380    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;381    {
;;;382        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L9.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;383    
;;;384        /* Configure UART0 and set UART0 baud rate */
;;;385        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L9.128|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;386    
;;;387    	/* Set UART receive time-out */
;;;388    	UART_SetTimeoutCnt(UART0, RX_TIMEOUT_CNT);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;389    
;;;390    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;391        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
00001c  68a0              LDR      r0,[r4,#8]
00001e  21f0              MOVS     r1,#0xf0
000020  4388              BICS     r0,r0,r1
000022  3010              ADDS     r0,r0,#0x10
000024  60a0              STR      r0,[r4,#8]
;;;392    
;;;393    	/* Enable UART Interrupt - */
;;;394    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000026  6860              LDR      r0,[r4,#4]
000028  2111              MOVS     r1,#0x11
00002a  4308              ORRS     r0,r0,r1
00002c  6060              STR      r0,[r4,#4]
00002e  2001              MOVS     r0,#1
000030  4914              LDR      r1,|L9.132|
000032  0300              LSLS     r0,r0,#12
000034  6008              STR      r0,[r1,#0]
;;;395    	
;;;396    	NVIC_EnableIRQ(UART02_IRQn);	
;;;397    
;;;398    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000036  f7fffffe          BL       CLK_GetCPUFreq
00003a  4601              MOV      r1,r0
00003c  a012              ADR      r0,|L9.136|
00003e  f7fffffe          BL       __2printf
;;;399    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000042  f7fffffe          BL       CLK_GetHXTFreq
000046  4601              MOV      r1,r0
000048  a016              ADR      r0,|L9.164|
00004a  f7fffffe          BL       __2printf
;;;400    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00004e  f7fffffe          BL       CLK_GetLXTFreq
000052  4601              MOV      r1,r0
000054  a019              ADR      r0,|L9.188|
000056  f7fffffe          BL       __2printf
;;;401    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00005a  f7fffffe          BL       CLK_GetPCLK0Freq
00005e  4601              MOV      r1,r0
000060  a01c              ADR      r0,|L9.212|
000062  f7fffffe          BL       __2printf
;;;402    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000066  f7fffffe          BL       CLK_GetPCLK1Freq
00006a  4601              MOV      r1,r0
00006c  a020              ADR      r0,|L9.240|
00006e  f7fffffe          BL       __2printf
                  |L9.114|
;;;403    
;;;404    
;;;405    	UART_WAIT_TX_EMPTY(UART0);
000072  69a0              LDR      r0,[r4,#0x18]
000074  00c0              LSLS     r0,r0,#3
000076  d5fc              BPL      |L9.114|
;;;406    }
000078  bd10              POP      {r4,pc}
;;;407    
                          ENDP

00007a  0000              DCW      0x0000
                  |L9.124|
                          DCD      0x04000010
                  |L9.128|
                          DCD      0x40070000
                  |L9.132|
                          DCD      0xe000e100
                  |L9.136|
000088  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00008c  4b5f4765
000090  74435055
000094  46726571
000098  203a2025
00009c  38640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L9.164|
0000a4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a8  47657448
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L9.188|
0000bc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c0  4765744c
0000c4  58544672
0000c8  6571203a
0000cc  20253864
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L9.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b30
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L9.240|
0000f0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f4  47657450
0000f8  434c4b31
0000fc  46726571
000100  203a2025
000104  38640d0a
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.UART_Process||, CODE, READONLY, ALIGN=2

                  UART_Process PROC
;;;309    
;;;310    void UART_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;311    {
;;;312    	/* Wait to receive UART data */
;;;313    	while(UART_RX_IDLE(UART0));
000002  4d0b              LDR      r5,|L10.48|
                  |L10.4|
000004  69a9              LDR      r1,[r5,#0x18]
000006  0088              LSLS     r0,r1,#2
000008  d4fc              BMI      |L10.4|
;;;314    
;;;315    	/* Start to received UART data */
;;;316    	g_bUART_RX_Received_Data_State = eUART_RX_Received_Data_NOT_Finish;        
00000a  4c0a              LDR      r4,|L10.52|
00000c  2001              MOVS     r0,#1
00000e  7020              STRB     r0,[r4,#0]
                  |L10.16|
;;;317    	/* Wait for receiving UART message finished */
;;;318    	while(g_bUART_RX_Received_Data_State != eUART_RX_Received_Data_Finish); 
000010  7821              LDRB     r1,[r4,#0]  ; g_bUART_RX_Received_Data_State
000012  2900              CMP      r1,#0
000014  d1fc              BNE      |L10.16|
;;;319    
;;;320    //	printf("\r\nUART0 Rx Received Data : %s\r\n",g_au8UART_RX_Buffer);
;;;321    //	printf("UART0 Rx Received Len : %d\r\n",g_u16UART_RX_length);	
;;;322    //	printf("UART0 Rx RDA (Fifofull) interrupt times : %d\r\n",g_u8UART_RDA_Trigger_Cnt);
;;;323    //	printf("UART0 Rx RXTO (Timeout) interrupt times : %d\r\n",g_u8UART_RXTO_Trigger_Cnt);
;;;324    
;;;325    	ParseCmd_Process();
000016  f7fffffe          BL       ParseCmd_Process
;;;326    	clear_RX_Buffer();
00001a  f7fffffe          BL       clear_RX_Buffer
;;;327    
;;;328    	/* Reset UART interrupt parameter */
;;;329    	UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
00001e  2111              MOVS     r1,#0x11
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       UART_EnableInt
;;;330    	g_u8UART_RDA_Trigger_Cnt = 0; // UART RDA interrupt times
000026  2000              MOVS     r0,#0
000028  7060              STRB     r0,[r4,#1]
;;;331    	g_u8UART_RXTO_Trigger_Cnt = 0; // UART RXTO interrupt times
00002a  70a0              STRB     r0,[r4,#2]
;;;332    }
00002c  bd70              POP      {r4-r6,pc}
;;;333    
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      0x40070000
                  |L10.52|
                          DCD      ||.data||

                          AREA ||i.clear_RX_Buffer||, CODE, READONLY, ALIGN=2

                  clear_RX_Buffer PROC
;;;137    
;;;138    void clear_RX_Buffer(void)
000000  2000              MOVS     r0,#0
;;;139    {
;;;140    	uint16_t i = 0;
;;;141    
;;;142    	//reset buffer
;;;143    	for(i = 0; i < RX_BUFFER_SIZE; i++)
;;;144    	{
;;;145    		g_au8UART_RX_Buffer[i] = 0;
000002  490b              LDR      r1,|L11.48|
000004  4602              MOV      r2,r0
                  |L11.6|
000006  540a              STRB     r2,[r1,r0]
000008  1c40              ADDS     r0,r0,#1
00000a  b280              UXTH     r0,r0                 ;143
00000c  2880              CMP      r0,#0x80              ;143
00000e  d3fa              BCC      |L11.6|
;;;146    	}
;;;147    
;;;148    	//reset cmd structure
;;;149    	cmd->header 		= 0x00;
000010  4808              LDR      r0,|L11.52|
000012  68c1              LDR      r1,[r0,#0xc]  ; cmd
;;;150    	cmd->function 		= (Function_Index)	0x00;
;;;151    	cmd->datalength		= 0x00;
;;;152    	for (i = 0 ; i < CMD_DATA_LEN ; i++)
000014  2000              MOVS     r0,#0
000016  700a              STRB     r2,[r1,#0]            ;149
000018  704a              STRB     r2,[r1,#1]            ;150
00001a  708a              STRB     r2,[r1,#2]            ;151
                  |L11.28|
;;;153    	{
;;;154    		cmd->data[i] 	= 0x00;
00001c  180b              ADDS     r3,r1,r0
00001e  1c40              ADDS     r0,r0,#1
000020  b280              UXTH     r0,r0                 ;152
000022  70da              STRB     r2,[r3,#3]
000024  2804              CMP      r0,#4                 ;152
000026  d3f9              BCC      |L11.28|
;;;155    	}
;;;156    	cmd->checksum 		= 0x00;
000028  71ca              STRB     r2,[r1,#7]
;;;157    	cmd->tail 			= 0x00;
00002a  720a              STRB     r2,[r1,#8]
;;;158    
;;;159    }
00002c  4770              BX       lr
;;;160    
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      ||.bss||
                  |L11.52|
                          DCD      ||.data||

                          AREA ||i.dump_buff_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buff_hex PROC
;;;90     
;;;91     void  dump_buff_hex(uint8_t *pucBuff, int nBytes)
000000  b5f8              PUSH     {r3-r7,lr}
;;;92     {
000002  460e              MOV      r6,r1
000004  4607              MOV      r7,r0
;;;93         int     nIdx, i;
;;;94     
;;;95         nIdx = 0;
000006  2500              MOVS     r5,#0
000008  e025              B        |L12.86|
                  |L12.10|
;;;96         while (nBytes > 0)
;;;97         {
;;;98             printf("0x%04X  ", nIdx);
00000a  4629              MOV      r1,r5
00000c  a015              ADR      r0,|L12.100|
00000e  f7fffffe          BL       __2printf
;;;99             for (i = 0; i < 16; i++)
000012  2400              MOVS     r4,#0
                  |L12.20|
;;;100                printf("%02x ", pucBuff[nIdx + i]);
000014  1928              ADDS     r0,r5,r4
000016  5c39              LDRB     r1,[r7,r0]
000018  a015              ADR      r0,|L12.112|
00001a  f7fffffe          BL       __2printf
00001e  1c64              ADDS     r4,r4,#1
000020  2c10              CMP      r4,#0x10              ;99
000022  dbf7              BLT      |L12.20|
;;;101            printf("  ");
000024  a014              ADR      r0,|L12.120|
000026  f7fffffe          BL       __2printf
;;;102            for (i = 0; i < 16; i++)
00002a  2400              MOVS     r4,#0
                  |L12.44|
;;;103            {
;;;104                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002c  1928              ADDS     r0,r5,r4
00002e  5c39              LDRB     r1,[r7,r0]
000030  4608              MOV      r0,r1
000032  3820              SUBS     r0,r0,#0x20
000034  285f              CMP      r0,#0x5f
000036  d203              BCS      |L12.64|
;;;105                    printf("%c", pucBuff[nIdx + i]);
000038  a010              ADR      r0,|L12.124|
00003a  f7fffffe          BL       __2printf
00003e  e002              B        |L12.70|
                  |L12.64|
;;;106                else
;;;107                    printf(".");
000040  a00f              ADR      r0,|L12.128|
000042  f7fffffe          BL       __2printf
                  |L12.70|
000046  1c64              ADDS     r4,r4,#1
000048  1e76              SUBS     r6,r6,#1
00004a  2c10              CMP      r4,#0x10              ;102
00004c  dbee              BLT      |L12.44|
;;;108                nBytes--;
;;;109            }
;;;110            nIdx += 16;
;;;111            printf("\n");
00004e  a00d              ADR      r0,|L12.132|
000050  3510              ADDS     r5,r5,#0x10
000052  f7fffffe          BL       __2printf
                  |L12.86|
000056  2e00              CMP      r6,#0                 ;96
000058  dcd7              BGT      |L12.10|
;;;112        }
;;;113        printf("\n");
00005a  a00a              ADR      r0,|L12.132|
00005c  f7fffffe          BL       __2printf
;;;114    }
000060  bdf8              POP      {r3-r7,pc}
;;;115    
                          ENDP

000062  0000              DCW      0x0000
                  |L12.100|
000064  30782530          DCB      "0x%04X  ",0
000068  34582020
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0
                  |L12.112|
000070  25303278          DCB      "%02x ",0
000074  2000    
000076  00                DCB      0
000077  00                DCB      0
                  |L12.120|
000078  202000            DCB      "  ",0
00007b  00                DCB      0
                  |L12.124|
00007c  256300            DCB      "%c",0
00007f  00                DCB      0
                  |L12.128|
000080  2e00              DCB      ".",0
000082  00                DCB      0
000083  00                DCB      0
                  |L12.132|
000084  0a00              DCB      "\n",0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;450    
;;;451    int main()
000000  f7fffffe          BL       SYS_Init
;;;452    {
;;;453        SYS_Init();
;;;454    
;;;455        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;456    
;;;457    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;458    
;;;459    	TIMER3_Init();
00000c  f7fffffe          BL       TIMER3_Init
                  |L13.16|
;;;460    	
;;;461        /* Got no where to go, just loop forever */
;;;462        while(1)
;;;463        {
;;;464    		UART_Process();
000010  f7fffffe          BL       UART_Process
000014  e7fc              B        |L13.16|
;;;465        }
;;;466    }
;;;467    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8UART_RX_Buffer
                          %        128

                          AREA ||.data||, DATA, ALIGN=2

                  g_bUART_RX_Received_Data_State
000000  01                DCB      0x01
                  g_u8UART_RDA_Trigger_Cnt
000001  00                DCB      0x00
                  g_u8UART_RXTO_Trigger_Cnt
000002  0000              DCB      0x00,0x00
                  g_u16UART_RX_length
000004  0000              DCW      0x0000
                  ||CNT||
000006  0000              DCW      0x0000
                  u16UART_RX_Buffer_Index
000008  0000              DCW      0x0000
00000a  0000              DCB      0x00,0x00
                  ||cmd||
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=0

                          EXPORTAS ||area_number.18||, ||.data||
                  BitFlag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d0fcd988____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_d0fcd988____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d0fcd988____REVSH|
#line 402
|__asm___6_main_c_d0fcd988____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
